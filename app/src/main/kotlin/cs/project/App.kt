/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
/**
 * Copyright (c) 2023, CS 346 Whiteboard App Team 210 Winter 2022.
 * All rights reserved.
 *
 * This code is licensed under the MIT License.
 */

package cs.project

import cs.project.business.ClientSocket
import cs.project.business.command.CommandFactory
import cs.project.business.command.CommandTypes
import cs.project.presentation.controller.*
import cs.shared.project.persistence.ClientPersistenceDao
import cs.shared.project.persistence.Connect
import cs.shared.project.persistence.model.Whiteboard
import cs.shared.project.presentation.model.DisplayModel
import javafx.application.Application
import javafx.fxml.FXMLLoader
import javafx.scene.Scene
import javafx.scene.input.KeyCode
import javafx.scene.input.KeyCodeCombination
import javafx.scene.input.KeyCombination
import javafx.stage.Stage
import javafx.util.Callback


class App : Application() {
    private lateinit var mainStage: Stage
    override fun start(stage: Stage) {

        val connect = Connect()
        connect.dbConnect()
        ClientSocket()

        mainStage = stage

        setUpMainStage(stage)
        val (loginScene, loginController) = setUpLoginScene()
        val mainScene = setUpMainScene(loginScene, loginController)

        val lastLoggedInUserId = ClientPersistenceDao.getLastLoggedInUser()
        if (lastLoggedInUserId != null) {
            ClientPersistenceDao.setUpDisplayModel(lastLoggedInUserId)
        }

        if (DisplayModel.currentUserId == null) {
            stage.scene = loginScene
        } else {
            stage.scene = mainScene
        }

        stage.show()
    }

    private fun setUpMainStage(stage: Stage) {
        stage.title = "Whiteboard app"
        stage.height = DisplayModel.selectedWindowHeight
        stage.width = DisplayModel.selectedWindowWidth
        stage.x = DisplayModel.selectedWindowPositionX
        stage.y = DisplayModel.selectedWindowPositionY

        stage.widthProperty().addListener { _, _, newVal ->
            DisplayModel.selectedWindowWidth = newVal.toDouble()
        }

        stage.heightProperty().addListener { _, _, newVal ->
            DisplayModel.selectedWindowHeight = newVal.toDouble()
        }

        stage.xProperty().addListener { _, _, newVal ->
            DisplayModel.selectedWindowPositionX = newVal.toDouble()
        }

        stage.yProperty().addListener { _, _, newVal ->
            DisplayModel.selectedWindowPositionY = newVal.toDouble()
        }
    }

    private fun setUpMainScene(loginScene: Scene, loginPageController: LoginPageController): Scene {
        val loader = FXMLLoader(javaClass.getResource("/fxml/Main.fxml"))
        loader.controllerFactory = Callback { controllerClass: Class<*> ->
            try {
                val controller = controllerClass.getDeclaredConstructor().newInstance()
                when (controller) {
                    is WhiteboardController -> DisplayModel.addView(observer = controller, isDataObserver = false)
                    is ToolBarController -> DisplayModel.addView(observer = controller, isDataObserver = true)
                    is MenuBarController -> {
                        DisplayModel.addView(observer = controller, isDataObserver = true)
                        controller.setLoginScene(loginScene)
                    }

                    is DetailTabController -> DisplayModel.addView(observer = controller, isDataObserver = false)
                    else -> {}
                }
                return@Callback controller
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        }
        val scene = Scene(loader.load(), DisplayModel.selectedWindowWidth, DisplayModel.selectedWindowHeight)
        setUpCommandHandler(scene)
        loginPageController.setMainScene(scene)

        return scene
    }

    private fun setUpLoginScene(): Pair<Scene, LoginPageController> {
        val loader = FXMLLoader(javaClass.getResource("/fxml/LoginPage.fxml"))
        val scene = Scene(loader.load(), 700.0, 700.0)
        val controller = loader.getController<LoginPageController>()
        return Pair(scene, controller)
    }

    private fun setUpCommandHandler(scene: Scene) {
        // ctrl + n
        scene.accelerators[KeyCodeCombination(KeyCode.N, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.JOIN).execute() }

        // ctrl + w
        scene.accelerators[KeyCodeCombination(KeyCode.W, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.REMOVE).execute() }

        // ctrl + q
        scene.accelerators[KeyCodeCombination(KeyCode.Q, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.CLOSE).execute() }

        // ctrl + f
        scene.accelerators[KeyCodeCombination(KeyCode.F, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.MAXIMIZE).execute() }

        // ctrl + m
        scene.accelerators[KeyCodeCombination(KeyCode.M, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.MINIMIZE).execute() }

        // ctrl + l
        scene.accelerators[KeyCodeCombination(KeyCode.L, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.LOG_OUT).execute() }

        // ctrl + c
        scene.accelerators[KeyCodeCombination(KeyCode.C, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.COPY).execute() }

        // ctrl + v
        scene.accelerators[KeyCodeCombination(KeyCode.V, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.PASTE).execute() }

        // ctrl + r
        scene.accelerators[KeyCodeCombination(KeyCode.R, KeyCombination.CONTROL_DOWN)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.RENAME).execute() }

        // Backspace button
        scene.accelerators[KeyCodeCombination(KeyCode.BACK_SPACE)] =
            Runnable { CommandFactory.createFromArgs(CommandTypes.DELETE).execute() }

        // ctrl + 1
        scene.accelerators[KeyCodeCombination(KeyCode.DIGIT1, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.PEN }

        // ctrl + 2
        scene.accelerators[KeyCodeCombination(KeyCode.DIGIT2, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.RECTANGLE }

        // ctrl + 3
        scene.accelerators[KeyCodeCombination(KeyCode.DIGIT3, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.CIRCLE }

        // ctrl + 4
        scene.accelerators[KeyCodeCombination(KeyCode.DIGIT4, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.LINE }

        // ctrl + 5
        scene.accelerators[KeyCodeCombination(KeyCode.DIGIT5, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.TEXT }

        // ctrl + ESC
        scene.accelerators[KeyCodeCombination(KeyCode.ESCAPE, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.SELECT }

        // ctrl + BACKSPACE
        scene.accelerators[KeyCodeCombination(KeyCode.BACK_SPACE, KeyCombination.CONTROL_DOWN)] =
            Runnable { DisplayModel.selectedToolType = Whiteboard.ToolType.ERASER }
    }

    override fun stop() {
        if (DisplayModel.currentUserId != null) {
            ClientPersistenceDao.insertLastLoggedInUser(DisplayModel.currentUserId!!)
            ClientPersistenceDao.insertOrUpdate(DisplayModel.currentUserId!!)
            ClientSocket.gracefulQuit()
        } else {
            ClientPersistenceDao.resetLastLoggedInUser()
        }
        super.stop()
        println("Stopping Application")
    }
}

